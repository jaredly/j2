##[fixtures]##
==[basic]==
--[input]--
() => 10
(a: 10) => 10
// hello

--[output:expected]--
():10 => 10
// () => 10
(a#[0]: 10):10 => 10
// (10) => 10
// hello

==[pattern type mismatch]==
--[input:shouldFail]--
((a, b): 10) => 10

--[output:expected]--
alias error:argWrongType=hfcfe64cbbd9e081476f4c8c4a4b2f8f2f992804f
((a#[0], b#[1]): @error:argWrongType() 10):10 => 10
// (@error:argWrongType() 10) => 10

==[wait just acessing variable, what happens]==
--[input]--
(a: int) => a

--[output:expected]--
alias int=h942cd67cf31d350ec1f39bcd0c933f586dcd176f
(a#[0]: int):int => a#[0]
// (int) => int

==[playground of dreams]==
--[input]--
(a) => takesInt(a) + 2
((a, b)) => 10
({a, what}) => 10
// this is adding constraints
(a) => takesInt(a) + takes10(a)
(a) => a(10)
// this would be a constraint on a of having the type (x: 10) => ???
// I feel like in this case, we'll be inferring ... ...
// some type variables as well? Because we can't really know?
// or, we could just infer it with a _ blank and say "fix it" thanks

--[output:failed]--
alias +=h3040ed1f3de0b98f18bd2b6daeb0e695cd0b608c error:argWrongType=hfcfe64cbbd9e081476f4c8c4a4b2f8f2f992804f error:notAFunction=h16ba48b37c7d5999c12c172bd1bbdeac9773c21a int=h942cd67cf31d350ec1f39bcd0c933f586dcd176f takes10=h454b6d446f18aea6c51a4b3599f3bf413c24ee76 takesInt=hd724811982a4afd89c79872d8c1d55048540a958
(a#[0]: "tvbl:1") => takesInt(@error:argWrongType(expected: :int) a#[0]) + 2
// ("tvbl:1") => int + 2
((a#[0], b#[1]): ("tvbl:2", "tvbl:3")):10 => 10
// (("tvbl:2", "tvbl:3")) => 10
({a#[0], what#[1]}: {a: "tvbl:2", what: "tvbl:3"}):10 => 10
// ({a: "tvbl:2", what: "tvbl:3"}) => 10
// this is adding constraints
(a#[0]: "tvbl:1") => takesInt(@error:argWrongType(expected: :int) a#[0]) + takes10(
    @error:argWrongType(expected: :10) a#[0],
)
// ("tvbl:1") => int + int
(a#[0]: "tvbl:1") => @error:notAFunction() a#[0](10)
// Error, no type!
// this would be a constraint on a of having the type (x: 10) => ???
// I feel like in this case, we'll be inferring ... ...
// some type variables as well? Because we can't really know?
// or, we could just infer it with a _ blank and say "fix it" thanks

--[builtins]--
//:value:takesInt:(a: int) => int
//:value:takes10:(a: 10) => int

==[New fixture]==
--[input]--
(a) => "${a}"

--[output:expected]--
alias string=hd978df838905e7e1bd7bb33530ae12436e3756f4
(a#[0]: string):string => "${a#[0]}"
// (string) => string

==[New fixture_]==
--[input]--
(a) => takesInt(a) + takes10(a)

--[output:expected]--
alias +=h3040ed1f3de0b98f18bd2b6daeb0e695cd0b608c int=h942cd67cf31d350ec1f39bcd0c933f586dcd176f takes10=h454b6d446f18aea6c51a4b3599f3bf413c24ee76 takesInt=hd724811982a4afd89c79872d8c1d55048540a958
(a#[0]: 10) => takesInt(a#[0]) + takes10(a#[0])
// (10) => int + int

--[builtins]--
//:value:takesInt:(a: int) => int
//:value:takes10:(a: 10) => int