let what = 10
alias string#[hd978df838905e7e1bd7bb33530ae12436e3756f4]
type Read = [`Read((), string)]
type Write = [`Write(string, ())]
let print = (x: string) => `Write(x, (()) => `Return())
let read = `Read((), (v: string) => `Return(v))
alias Read#[h39d4a8221a80e1486be57f401a27a7eb6b0afc3c] Task#[h67d00eba961cd5135110775d8654598dc22e7274] task#[h1d6249a7982fd223e2fe4bc614e77aba75d5fabe] withHandler#[ha096a125d17e577335cba67a01ae6f08c8a8254b]
let alwaysRead = <Inner: task, R>(readResponse: string, task: Task<[Read | Inner], R>): Task<
    [Inner],
    R,
> => {
    switch task {
        `Return(result) => `Return(result);
        `Read(_, k) => alwaysRead<Inner, R>(readResponse, k(readResponse));
        otherwise => withHandler<[Inner], R, [Read], R>(
            otherwise,
            (task) => alwaysRead<Inner, R>(readResponse, task),
        );
    };
}
alias Write#[heb2d48403fd429ed06727a7877b3a05cd5229596] andThen#[h350018996371f8a646e144d264506c10d2ebde8b]
let collect = <Inner: task>(task: Task<[Write | Inner], ()>): Task<Inner, string> => switch task {
    `Return() => `Return("end");
    `Write(v, k) => andThen<Inner, [], string, string>(
        collect<Inner>(k(())),
        (res) => `Return("${v}\n${res}"),
    );
    otherwise => withHandler<Inner, (), Write, string>(otherwise, collect<Inner>);
}
alias ==#[ha4d3e814b6e823e777273070f4e78f59487993dc] collect#[hdcf352d196b379fc15b78bac63e94c59a25d8e25] print#[h7f2c4f7e1b479be94892d7e98869816c0fc8683e]
{
    let `Return(v) = collect<[]>((() => {
        print("Hello")!;
        print("World")!;
    })());
    v == "Hello\nWorld\nend";
}
alias alwaysRead#[h9cd0f1dffaee1da3463a9c7da5ab4e10ee2cb3b3] read#[hb4960a73062670598fa2100bb3c961af8368de28]
{
    let `Return(v) = collect<[]>(
        alwaysRead<[Write], ()>("hi", (() => {
            print("${read!} and ${read!}")!;
        })()),
    );
    v == "hi and hi\nend";
}
let reverse: (t: Task<Write, ()>) => Task<Write, ()> = (task: Task<Write, ()>) => switch task {
    `Return(v) => `Return(v);
    `Write(v, k) => (() => {
        reverse(k(()))!;
        print(v)!;
    })();
}
alias eq#[h160938f3c683c32e39a494546124c1d40bcde082]
let expect = <T: eq>(`Return(m): Task<[], T>, e: T) => m == e
alias expect#[h1f12eaef67c0292e9145431abf15b7bf90d1ceb6] reverse#[h13da32ef4105c9d6a78695c647de1fd3f507b58b]
expect<string>(
    collect<[]>(reverse((() => {
        print("A")!;
        print("B")!;
        print("C")!;
    })())),
    "C\nB\nA\nend",
)
alias bool#[h62d1b70cb3ae567d8df7d48fe634fd37fd0f5150]
type Decide = [`Decide((), bool)]
alias Decide#[hd53a584b44751c2fbfdf1a3826912162cf36c920]
let decide: Task<Decide, bool> = `Decide((), (b: bool) => `Return(b))
alias decide#[h108816cca299511520fd3d43f5ab7840105958ea]
let choose = <T>(x: T, y: T) => {
    if decide! {
        x;
    } else {
        y;
    };
}
let pickTrue: <T>(Task<Decide, T>) => T = <T>(task: Task<Decide, T>): T => switch task {
    `Return(v) => v;
    `Decide(_, k) => pickTrue<T>(k(true));
}
alias -#[h4dd9308469e477a4a756b4b286de0625d5a98af9] choose#[h42dd33e9bb01737d406ba5c4241da56f1096c111] int#[h942cd67cf31d350ec1f39bcd0c933f586dcd176f]
let chooseDiff = () => {
    let x1 = choose<int>(15, 30)!;
    let x2 = choose<int>(5, 10)!;
    x1 - x2;
}
alias chooseDiff#[h0dd1475991c109145d9e76868cfecef5ddabd1c5] pickTrue#[h5ac610a9d6438244b3b00d7ea3f359988100373a]
pickTrue<int>(chooseDiff()) == 10
alias >#[hc1d03250b26806868f520136d8a763b0c0edff9b]
let pickMax: (Task<Decide, int>) => int = (task: Task<Decide, int>): int => {
    switch task {
        `Return(v) => v;
        `Decide(_, k) => {
            let one = pickMax(k(true));
            let two = pickMax(k(false));
            if one > two {
                one;
            } else {
                two;
            };
        };
    };
}
alias pickMax#[h90a1b556aa5dabde2290284e49839f47c9e408ef]
pickMax(chooseDiff()) == 25
type Fail = [`Fail((), [])]
let fail = `Fail((), ())
alias +#[h3040ed1f3de0b98f18bd2b6daeb0e695cd0b608c] Fail#[h2b5445c7100f54327177f27fdbdafaf46e537c5e] fail#[h729036fc5f9ed540cc3ad62576eeed107866166b]
let chooseInt: (int, int) => Task<[Decide | Fail], int> = (m: int, n: int): Task<[Decide | Fail], int> => {
    if m > n {
        fail!;
    } else {
        if decide! {
            m;
        } else {
            chooseInt(m + 1, n)!;
        };
    };
}
alias *#[hc964b8e32721e8a2764054a069ab98c885f00921] chooseInt#[h51d8a99418bd42082d9a3915220cb16ea0e95898] isSquare#[hb6ce0e79bc7b4832f4b2b564eac779a40d12f007]
let pythagorean = (m: int, n: int) => {
    let a = chooseInt(m, n - 1)!;
    let b = chooseInt(a + 1, n)!;
    let a2 = a * a;
    let b2 = b * b;
    if isSquare(a2 + b2) {
        (a, b);
    } else {
        fail!;
    };
}
let backtrack: <T>(Task<[Decide | Fail], T>, () => T) => T = <T>(
    task: Task<[Decide | Fail], T>,
    orElse: () => T,
): T => {
    switch task {
        `Decide(_, k) => {
            backtrack<T>(k(true), () => backtrack<T>(k(false), orElse));
        };
        `Fail(_, _) => {
            orElse();
        };
        `Return(x) => x;
    };
}
alias backtrack#[h8864f73597b6dc6b53002132e677411e5db4e989] pythagorean#[hce71fb6dfb5bbec59351789b6279dd5deba69d29]
let backtrackPythag = (m: int, n: int) => backtrack<(int, int)>(pythagorean(m, n), () => (0, 0))
alias backtrackPythag#[h61b3bf5e1d048138d818fdd8d2a8b22afdce742d]
backtrackPythag(4, 15)
backtrackPythag(7, 10)