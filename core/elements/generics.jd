##[builtins]##
//:value:hello:<T>(v: T) => T
//:decorator:decorate
//:value:multi:<A, B>(a: A, b: B) => A
//:value:bounded:<A: int>(a: A) => A
//:value:boundedDefault:<A: int, B: uint = 10>(a: A, b: B) => A
//:value:takesInt:(a: int) => int
//:type:Array:<Element, Length: uint>
//:value:takesArray:(ar: Array<string, 10>) => int
//:value:anArray:Array<string, 10>
//:value:iadd:<A, B>(a: A, b: B) => A + B

##[fixtures]##
==[basic]==
--[input]--
hello<int>(10)

--[output:expected]--
alias hello=hf6e269898d7d9d035467350db13cfa38ac824c31 int=h942cd67cf31d350ec1f39bcd0c933f586dcd176f
hello<int>(10)
// int

==[decorate target]==
--[input]--
(@decorate() hello)<10>(10)

--[output:expected]--
alias decorate=h5a7fc9170718190f9388084b28fb49f6cb4602fc hello=hf6e269898d7d9d035467350db13cfa38ac824c31
(@decorate() hello)<10>(10)
// 10

==[multiple]==
--[input]--
multi<int, string>
multi<int, string>(10, "hello")

--[output:expected]--
alias int=h942cd67cf31d350ec1f39bcd0c933f586dcd176f multi=h088d53f5e3ddc6bf12a7e3054c4a52ebae49789d string=hd978df838905e7e1bd7bb33530ae12436e3756f4
multi<int, string>
// (a: int, b: string) => int
multi<int, string>(10, "hello")
// int

==[bounded]==
--[input]--
bounded<10>(10)

--[output:expected]--
alias bounded=h6b72cf1b6234557dd3846b2452db4a5f991da15d
bounded<10>(10)
// 10

==[bound fail]==
--[input:shouldFail]--
bounded<string>("wat")

--[output:expected]--
alias bounded=h6b72cf1b6234557dd3846b2452db4a5f991da15d error:argWrongType=hfcfe64cbbd9e081476f4c8c4a4b2f8f2f992804f int=h942cd67cf31d350ec1f39bcd0c933f586dcd176f string=hd978df838905e7e1bd7bb33530ae12436e3756f4
bounded<@error:argWrongType(expected: :int) string>("wat")
// Error, no type!

==[wrong args]==
--[input:shouldFail]--
bounded<int, string>(20)
takesInt<int>(10)

--[output:expected]--
alias bounded=h6b72cf1b6234557dd3846b2452db4a5f991da15d error:extraArg=haae12b260f3d25abb4b67dfe8895a3c6fb00eb59 error:notATypeVars=hf975b139e8972496b3acf4c415c5bc460d39dd08 error:wrongNumberOfTypeArgs=h861c5babf48bbd7fc0325178615769bdb2837d5a int=h942cd67cf31d350ec1f39bcd0c933f586dcd176f string=hd978df838905e7e1bd7bb33530ae12436e3756f4 takesInt=hd724811982a4afd89c79872d8c1d55048540a958
(@error:wrongNumberOfTypeArgs() bounded<int, @error:extraArg() string>)(20)
// int
(@error:notATypeVars() takesInt<int>)(10)
// int

==[arg default]==
--[input:shouldFail]--
@test:type(:Array<int, string, int>) 10

--[output:expected]--
alias Array=h8de4ecae93abe8de85536031f6f8a05742a6ee53 error:argWrongType=hfcfe64cbbd9e081476f4c8c4a4b2f8f2f992804f error:extraArg=haae12b260f3d25abb4b67dfe8895a3c6fb00eb59 error:wrongNumberOfTypeArgs=h861c5babf48bbd7fc0325178615769bdb2837d5a int=h942cd67cf31d350ec1f39bcd0c933f586dcd176f string=hd978df838905e7e1bd7bb33530ae12436e3756f4 test:type=he071eaec952a7917f20d1828e42268ca3a10c513 uint=h7f3ebb1dcbb38933edcaaabbbed6729a7c3bec83
@test:type(
    :@error:wrongNumberOfTypeArgs() Array<
        int,
        @error:argWrongType(expected: :uint) string,
        @error:extraArg() int,
    >,
) 10
// 10

==[taking a generic argument]==
--[input:shouldFail]--
takesArray(10)
takesArray(anArray)

--[output:expected]--
alias anArray=he3109f44b98fb07fb831ba6a1d2f34047deb6258 Array=h8de4ecae93abe8de85536031f6f8a05742a6ee53 error:argWrongType=hfcfe64cbbd9e081476f4c8c4a4b2f8f2f992804f int=h942cd67cf31d350ec1f39bcd0c933f586dcd176f string=hd978df838905e7e1bd7bb33530ae12436e3756f4 takesArray=h8398f2442dd88143954c31fb3337a3ed6dd0edb7
takesArray(@error:argWrongType(expected: :Array<string, 10>) 10)
// int
takesArray(anArray)
// int

==[chained]==
--[input]--
type x=<A: int><B: int>int
type y=x<int><10>

--[output:expected]--
alias A=1 B=2 int=h942cd67cf31d350ec1f39bcd0c933f586dcd176f x=h828ef9fc4a9b49783015a4201fa49b8c1d488888
type x = <A: int><B: int>int
// h828ef9fc4a9b49783015a4201fa49b8c1d488888
type y = x<int><10>
// h497787948da674206a9c354d2a0e7b6d479ea1f9

==[parnes]==
--[input]--
type Array = <Element, Length: uint>int
type x = (@test:type() Array)<int, 10>

--[output:expected]--
alias Array=h9d5ae22671a35a1b18f6cf92f162971cc7be95f0 Element=2 int=h942cd67cf31d350ec1f39bcd0c933f586dcd176f Length=3 test:type=he071eaec952a7917f20d1828e42268ca3a10c513 uint=h7f3ebb1dcbb38933edcaaabbbed6729a7c3bec83
type Array = <Element, Length: uint>int
// h9d5ae22671a35a1b18f6cf92f162971cc7be95f0
type x = (@test:type() Array)<int, 10>
// hfe704d0d111b5ed5d9985e34d8aa7b7f5b898c68

==[variance?]==
--[input]--
type One = (v: int) => int
type Two = (v: 10) => int
// Should Three accept Two? NO
// Should Four accept One? YES
type Three = (l: One) => string // might pass any int to it
type Four = (l: Two) => string // will only pass 10 to it

// ## OK now to the actual question ##
type OneInt = <T: int>(v: T) => string
type OneTen = <T: 10>(v: T) => string
type TOneInt = (v: OneInt) => string
type TOneTen = (v: OneTen) => string
// ## Does TOneInt accept TOneTen? NO
// ## Does TOneTen accept TOneInt? YES
// ## We know that 10 matches int, but int does not match 10.
// ## I would expect it to reverse here?
type TwoInt = <T: int>(v: (m: T) => string) => string
type TwoTen = <T: 10>(v: (m: T) => string) => string
// ## And then I think it would reverse again here?

--[output:expected]--
alias int=h942cd67cf31d350ec1f39bcd0c933f586dcd176f One=h782f3ce2b7c72249be64f4b9b8d4f0360597e092 OneInt=h6070a8d3d26e3d7f986910d41d0f7887239bbc53 OneTen=heaf5050c116bbd388ebffb58906eee6742fdfd59 string=hd978df838905e7e1bd7bb33530ae12436e3756f4 T=1 Two=h7e3fe5c70f6f8ff6d5e481b2cf6ac0518e0eb98e
type One = (v: int) => int
// h782f3ce2b7c72249be64f4b9b8d4f0360597e092
type Two = (v: 10) => int
// h7e3fe5c70f6f8ff6d5e481b2cf6ac0518e0eb98e
// Should Three accept Two? NO
// Should Four accept One? YES
type Three = (l: One) => string
// h0b8a3ae17330ce83d0f21f10ce6f9d08c1aedf2b
// might pass any int to it
type Four = (l: Two) => string
// hf79e982509d8648ed2d1661e08600dda28c8f78c
// will only pass 10 to it
// ## OK now to the actual question ##
type OneInt = <T: int>(v: T) => string
// h6070a8d3d26e3d7f986910d41d0f7887239bbc53
type OneTen = <T: 10>(v: T) => string
// heaf5050c116bbd388ebffb58906eee6742fdfd59
type TOneInt = (v: OneInt) => string
// hdde629475432863640365d42cb440dca9d9552c8
type TOneTen = (v: OneTen) => string
// h2a7823a2e701109b4e9d42d9baaaf8506c130f12
// ## Does TOneInt accept TOneTen? NO
// ## Does TOneTen accept TOneInt? YES
// ## We know that 10 matches int, but int does not match 10.
// ## I would expect it to reverse here?
type TwoInt = <T: int>(v: (m: T) => string) => string
// hf8b98e52f22406c82c65c3970775940dfc7b74f7
type TwoTen = <T: 10>(v: (m: T) => string) => string
// hb8fd053e2534f8fc54483991f84df459e05d2981
// ## And then I think it would reverse again here?

==[New fixture_]==
--[input]--
type IntA = (x: int) => string
type TenA =  (x: 10) => string
// # First we have basic variance. IntA can be passed to something expected a TenA, but not reversed.
type IntR = (x: string) => int
type TenR = (x: string) => 10
// # On the other hand, something producing an int can't be given to someone expecting something that produces a 10.
type Int = <T: int>(x: T) => T
type Ten = <T: 10>(x: T) => T
// # BUT, on the final hand, once you lock it down to something concrete, the return value isn't "maybe a subset of T", it's precisely T. Ok so I don't think we have to get fancy.
// 
// ### OK, so Something T
type TInt = (v: Int) => string
type TTen = (v: Ten) => string

--[output:expected]--
alias int=h942cd67cf31d350ec1f39bcd0c933f586dcd176f Int=h8678d38cd9d1fd0d89a15430c458706ac98e6739 string=hd978df838905e7e1bd7bb33530ae12436e3756f4 T=1 Ten=h08bdce5f62ee75b818f7c5c2fcf9a69e1c461ffc
type IntA = (x: int) => string
// h99e09c4aaaca6ed1c46e24494373cd247ed0eb51
type TenA = (x: 10) => string
// h10d2509a1200dd0d74768248828b5290f9f33ade
// # First we have basic variance. IntA can be passed to something expected a TenA, but not reversed.
type IntR = (x: string) => int
// h7f5e7a0fee31ba5a670158815ad90a022bea3db0
type TenR = (x: string) => 10
// h28b34d4b2abc48d15ad971f92d7ca8729569ba11
// # On the other hand, something producing an int can't be given to someone expecting something that produces a 10.
type Int = <T: int>(x: T) => T
// h8678d38cd9d1fd0d89a15430c458706ac98e6739
type Ten = <T: 10>(x: T) => T
// h08bdce5f62ee75b818f7c5c2fcf9a69e1c461ffc
// # BUT, on the final hand, once you lock it down to something concrete, the return value isn't "maybe a subset of T", it's precisely T. Ok so I don't think we have to get fancy.
//
// ### OK, so Something T
type TInt = (v: Int) => string
// h5561e913f4b2dfacd4555c3709b88b9d1d266b98
type TTen = (v: Ten) => string
// h592b94795726f53359bebfd7424b262f89a162d2

==[default arg type]==
--[input]--
type DArray = <Element, Length: uint = uint>int
type Marray = DArray<int>
// type TArray = DArray<int, 10>

--[output:expected]--
alias DArray=h0b670aef5a7bc3d9e597ec82b38f910e2d9c88b9 Element=2 int=h942cd67cf31d350ec1f39bcd0c933f586dcd176f Length=3 uint=h7f3ebb1dcbb38933edcaaabbbed6729a7c3bec83
type DArray = <Element, Length: uint = uint>int
// h0b670aef5a7bc3d9e597ec82b38f910e2d9c88b9
type Marray = DArray<int>
// h03e239776edd32e96d1dafb50147600765e3251f
// type TArray = DArray<int, 10>

==[New fixture___]==
--[input]--
boundedDefault<int>

--[output:expected]--
alias boundedDefault=hc4316951341561217c1d42557785019239254ba1 int=h942cd67cf31d350ec1f39bcd0c933f586dcd176f
boundedDefault<int>
// (a: int, b: 10) => int

==[generic arg works]==
--[input]--
takesArray(anArray)

--[output:expected]--
alias anArray=he3109f44b98fb07fb831ba6a1d2f34047deb6258 int=h942cd67cf31d350ec1f39bcd0c933f586dcd176f takesArray=h8398f2442dd88143954c31fb3337a3ed6dd0edb7
takesArray(anArray)
// int

==[New fixture]==
--[input]--
iadd<10, 20>(10, 20)

--[output:expected]--
alias iadd=h70384774f43136b4971f36930f8dd583892ac08d
iadd<10, 20>(10, 20)
// 10 + 20