##[builtins]##
//:type:Array:<El>

##[fixtures]##
==[basic parsing]==
--[input]--
type x = [`hi | `what(int)]

--[output:expected]--
alias int=h942cd67cf31d350ec1f39bcd0c933f586dcd176f
type x = [ `hi | `what(int) ]

==[recursive!]==
--[input]--
type Tree = <T>[Node<T> | `Leaf(T)]
and Node = <T>[`Tree(Array<Tree<T>>)]

--[output:expected]--
alias Array=he7bf755aa7882e15fa79faeef0820a69a5955b78
type Tree = <T#[0]>[ Node#[r1]<T#[0]> | `Leaf(T#[0]) ]
and Node = <T#[1]>[ `Tree(Array<Tree#[r0]<T#[1]>>) ]

==[validate enum cases]==
--[input:shouldFail]--
type y = Array<10>
type z = [`Z]
type x = [int | `Hello | y | z]

--[output:expected]--
alias Array=he7bf755aa7882e15fa79faeef0820a69a5955b78 error:notAnEnum=hf16010a7ae4b37140f787a2e06b17030e8329fb3 int=h942cd67cf31d350ec1f39bcd0c933f586dcd176f y=h1b0e8917e6173706d1c1e1863436851ee8877ebb z=hb5d906b1c904d6f7c6cc56054ef2fadb9d951d02
type y = Array<10>
type z = [ `Z ]
type x = [ @error:notAnEnum() int | `Hello | @error:notAnEnum() y | z ]

==[recursive bound propagation]==
--[input]--
type What = <T: int>[ `Hello(What<10>) ]

--[output:expected]--
alias int=h942cd67cf31d350ec1f39bcd0c933f586dcd176f
type What = <T#[0]: int>[ `Hello(What#[r0]<10>) ]

==[recursive bound propagation, failure]==
--[input:shouldFail]--
type X = <T: int>[ `Hello(X<"string">) ]

--[output:expected]--
alias error:argWrongType=hfcfe64cbbd9e081476f4c8c4a4b2f8f2f992804f int=h942cd67cf31d350ec1f39bcd0c933f586dcd176f
type X = <T#[0]: int>[ `Hello(X#[r0]<@error:argWrongType(expected: :int) "string">) ]

==[recursive bound, own tvar]==
--[input]--
type X = <T: int>[ `X(X<T>) ]
type M = (<What>[ `X(What) | M ])<int>
type N = int

--[output:expected]--
alias int=h942cd67cf31d350ec1f39bcd0c933f586dcd176f
type X = <T#[0]: int>[ `X(X#[r0]<T#[0]>) ]
type M = (<What#[0]>[ `X(What#[0]) | M#[r0] ])<int>
type N = int

==[recursive bound, wrong tvar]==
--[input:shouldFail]--
type X = <T: int, N: string>[ `X(X<N, N>) ]

--[output:expected]--
alias error:argWrongType=hfcfe64cbbd9e081476f4c8c4a4b2f8f2f992804f int=h942cd67cf31d350ec1f39bcd0c933f586dcd176f string=hd978df838905e7e1bd7bb33530ae12436e3756f4
type X = <T#[0]: int, N#[1]: string>[ `X(X#[r0]<@error:argWrongType(expected: :int) N#[1], N#[1]>) ]

==[enum join should indicate failure]==
--[input:shouldFail]--
type One = [`A | `B]
type Two = [`A | One]
type Three = [`A(int) | One]

--[output:failed]--
alias int=h942cd67cf31d350ec1f39bcd0c933f586dcd176f One=h9e64a5fc10caacb63b17e70f46f1ffdadfd3fbb0
type One = [ `A | `B ]
type Two = [ `A | One ]
type Three = [ `A(int) | One ]

==[duplicate recursive]==
--[input:shouldFail]--
type One = [`A | Two]
and Two = [`A(int)]

--[output:failed]--
alias int=h942cd67cf31d350ec1f39bcd0c933f586dcd176f
type One = [ `A | Two#[r1] ]
and Two = [ `A(int) ]

==[self recursive]==
--[input:shouldFail]--
type Self = [`A | Self]

--[output:failed]--
type Self = [ `A | Self#[r0] ]

==[infinite]==
--[input:shouldFail]--
type X = Y#[r1]
and Y = X#[r0]

type M = @type:shouldMatch(:X) 1

type A = [ `A | B#[r1] ]
and B = [ `B | A#[r0] ]

type N = @type:shouldMatch(:A) [`A]

--[output:failed]--
alias A=ha7d22ed06bfa4f8db40cde871402addda29f6dcb X=h2a44c6ce7a7328fee222979f96c5792b0583f64e
type X = Y#[r1]
and Y = X#[r0]
type M = @type:shouldMatch#[:unresolved:](:X) 1
type A = [ `A | B#[r1] ]
and B = [ `B | A#[r0] ]
type N = @type:shouldMatch#[:unresolved:](:A) [ `A ]

==[duplicate]==
--[input:shouldFail]--
type X = [`A | `A(int)]

--[output:failed]--
alias int=h942cd67cf31d350ec1f39bcd0c933f586dcd176f
type X = [ `A | `A(int) ]