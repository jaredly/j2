@type:shouldMatch(:[ `Hi ]) [ `Hi ]

@type:shouldNotMatch(:[ `One ])
@type:shouldMatch(:[ `One | `Two ]) [ `Two ]

@type:shouldMatch(:[ `One | `Two ])
@type:shouldNotMatch(:[ `One ]) [ `One | `Two ]

@type:shouldNotMatch(:[ `Hi(int) ]) [ `Hi(float) ]

@type:shouldMatch(:[ `Hi(int) ]) (<T#[0]>[ `Hi(T#[0]) ])<int>

@type:shouldNotMatch(:[ `One | `Two ]) [ `Two | * ]

@type:shouldMatch(:[ `One | * ])
@type:shouldMatch(:[ * ]) [ `One | `Two ]

@type:shouldMatch(:[ `Hi(int) ]) [ `Hi(10) ]

@type:shouldMatch(:[ `Hi(int) ]) [ `Hi(10) | `Hi(int) ]

type One = [ `A | `B ]

@type:shouldMatch(:One) [ `A ]

@type:shouldMatch(:One) [ `A | One ]

type Tree = [ Node#[r1] | `Leaf ]
and Node = [ `Tree(Tree#[r0]) ]

// Ok so the story here is: we need to replace all `#[r]` recursive references with the appropriate global reference
// when hytrating the type. Right? Seems like that would do the trick...
@type:shouldMatch(:Tree) [ `Leaf ]

// These should not trigger an infinite loop ðŸ˜‚
type X = Y#[r1]
and Y = X#[r0]

@type:shouldNotMatch(:X) 1

type A = [ `A | B#[r1] ]
and B = [ `B | A#[r0] ]

@type:shouldNotMatch(:A) [ `A ]

type N = [ `A((int, float)) ]

@type:shouldMatch(:{x: [ `A | `B ]}) {x: [ `A ]}

// Unification!
@type:shouldMatch(:[ `Failure([ `TooBad | `Timeout | `C ]) ]) [ `Failure([ `TooBad ]) | `Failure([ `Timeout ]) ]

@type:shouldMatch(:[ `Failure(([ `TooBad | `Timeout | `C ], int)) ]) [ `Failure(([ `TooBad ], int)) | `Failure((
    [ `Timeout ],
    int,
)) ]
