// An AST node

import { Ctx } from '../';

/*:peg:
Int "int" = _ contents:$("-"? [0-9]+) 
*/

// Autogenerated
// Parser AST types have P_ prefix b/c I won't write them as much I hope
export type P_Int = { type: 'Int'; contents: string; location: Location };

// I define by handdd. It gets glommed into `Expression`
// And a walker gets made for it automatically.
export type Int = { type: 'Int'; value: number; location: Location };

// // The types of `fromAst` inform the "FromAst" transformer ...
// export const IntFromAst = (
//     { contents, location }: P_Int,
//     ctx: Context,
// ): Int => ({
//     type: 'Int',
//     value: +contents,
//     location,
// });

// This is so my
export const typeOf = (node: Int) => ({ type: 'builtin', name: 'int' });
export const checkConsistency = (node: Int) => []; // no errors

export type I_Int = Int; // no change for IR

export const IntToIR = (node: Int) => node;

export const I_IntToString = (node: I_Int) => node.value.toString();

// So we run a script, and all of the sudden
// after `grammar` we have the type, right?
// that's how I want to do it?
// And we make `index.js` such that I can be importing
// all the things I need.
